# 实验三 内存管理

## 实验要求

* 阅读[VirtualAlloc](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)、[VirtualFree](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualfree)、[VirtualProtect](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect)等函数的官方文档。
* 编程使用malloc分配一段内存，测试是否这段内存所在的整个4KB都可以写入读取。
* 使用VirtualAlloc分配一段，可读可写的内存，写入内存，然后将这段内存改为只读，再读数据和写数据，看是否会有异常情况。然后VirtualFree这段内存，再测试对这段内存的读写释放正常。

## 实验步骤

### VirtualAlloc

* 功能：
在调用进程的虚拟地址空间中保留，提交或更改页面区域的状态。该功能分配的内存将自动初始化为零。

* 语法：

    ```bash
    LPVOID VirtualAlloc(
    LPVOID lpAddress, //要分配的区域的起始地址
    SIZE_T dwSize,//区域的大小，以字节为单位
    DWORD  flAllocationType,//内存分配的类型
    DWORD  flProtect//对要分配的页面区域的内存保护
    );
    ```

* 参数：
    * lpAddress：</br>要分配的区域的起始地址。如果正在保留内存，则将指定的地址四舍五入到分配粒度的最接近倍数。如果内存已被保留并正在提交，则地址将向下舍入到下一个页面边界。若要确定页面的大小和主机上的分配粒度，请使用 GetSystemInfo函数。如果此参数为 NULL，则系统确定将区域分配到哪里。

    * dwSize：</br>区域的大小，以字节为单位。如果lpAddress参数为 NULL，则此值将四舍五入到下一页的边界。否则，分配的页面包括从lpAddress到 lpAddress + dwSize范围内包含一个或多个字节的所有页面。这意味着跨越页面边界的2字节范围会导致两个页面都包含在分配的区域中。
    * flAllocationType：</br>内存分配的类型。
    * flProtect：</br>对要分配的页面区域的内存保护。如果正在提交页面，则可以指定任何一个内存保护常量。如果lpAddress指定一个安全区域内的地址，则flProtect不能为以下任何值：
        ```bash
        PAGE_NOACCESS
        PAGE_GUARD
        PAGE_NOCACHE
        PAGE_WRITECOMBINE
       ```
* 返回值：
   * 如果函数成功，则返回值是页面分配区域的基地址。
   * 如果函数失败，则返回值为NULL。要获取扩展的错误信息，请调用GetLastError。

### VirtualFree

* 功能：
在调用进程的虚拟地址空间内释放，取消授权或释放并取消授权页面区域。
* 语法：
    ```bash
    BOOL VirtualFree(
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD  dwFreeType
    );
    ```
* 参数
    * lpAddress：
指向要释放的页面区域的基地址的指针。如果dwFreeType参数为MEM_RELEASE，则当保留页面区域时，此参数必须是VirtualAlloc函数返回的基地址 。
    * dwSize：
    要释放的内存区域的大小，以字节为单位。如果dwFreeType参数为MEM_RELEASE，则此参数必须为0。该函数释放对VirtualAlloc的初始分配调用中保留的整个区域 。如果dwFreeType参数为MEM_DECOMMIT，则该函数将取消使用从lpAddress参数到的范围内包含一个或多个字节的所有内存页面(lpAddress+dwSize)。例如，这意味着跨越页面边界的2字节内存区域将导致两个页面都不再使用。如果lpAddress是VirtualAlloc返回的基地址， 并且dwSize为0，则该函数将取消使用VirtualAlloc分配的整个区域 。之后，整个区域都处于保留状态。
    * dwFreeType：
    自由操作的类型
* 返回值
    * 如果函数成功，则返回值为非零。
    * 如果函数失败，则返回值为0（零）。要获取扩展的错误信息，请调用 GetLastError。

### VirtualProtect

* 功能：
在调用进程的虚拟地址空间中更改对已提交页面区域的保护。
* 语法：
    ```bash
    BOOL VirtualProtect(
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD  flNewProtect,
    PDWORD lpflOldProtect
    );
    ```
* 参数：
    * lpAddress：
    指针地址，它描述要更改其访问保护属性的页面区域的起始页面。使用MEM_RESERVE调用VirtualAlloc或 VirtualAllocEx函数 时，指定区域中的所有页面必须在分配的同一保留区域内 。这些页面不能跨越使用 MEM_RESERVE分别调用VirtualAlloc或 VirtualAllocEx分配的相邻保留区域。

    * dwSize：
    要更改其访问保护属性的区域的大小，以字节为单位。受影响的页面区域包括从lpAddress参数到 的范围内包含一个或多个字节的所有页面 (lpAddress+dwSize)。这意味着跨越页面边界的2字节范围会导致两个页面的保护属性都被更改。

    * flNewProtect：
    内存保护选项。此参数可以是 内存保护常量之一。对于映射视图，此值必须与映射视图时指定的访问保护兼容。

    * lpflOldProtect：
    指向变量的指针，该变量接收页面的指定区域中第一页的先前访问保护值。如果此参数为NULL或未指向有效变量，则函数将失败。
* 返回值：
    * 如果函数成功，则返回值为非零。
    * 如果函数失败，则返回值为零。要获取扩展的错误信息，请调用 GetLastError。

### 编程使用malloc分配空间

```bash
#include<stdio.h>
#include<stdlib.h>

int main()
{
	int i = 0, anum;
	char *p;

	p = (char *)malloc(100);  //只分配100个字节的空间
	if (p)
		printf("Memory Allocated at: %x\n", p);
	else
		printf("Not Enough Memory!\n");
	for (i = 0; i<4096; i++)
	{
		p[i] = 'a';
	}
	anum = i;
	printf("共写入%d字节\n", anum);
	
	for (i = 0; i<4096; i++)
	{
		if (p[i] != 'a')
		{
			anum--;
		}
	}
	printf("共%d字节读取正确\n", anum);

	free(p);
	return 0;
}
```
* 只分配了100个字节的空间，但是这段内存所在的4096个字节都可以写入和读取。

### 编程使用VirtualAlloc VirtualFree

```bash
#include <windows.h>
#include <stdio.h>
void main()
{
 SYSTEM_INFO sf;
 GetSystemInfo(&sf);
 //分配内存，标记为提交、可读可写
 LPVOID lpvBase = VirtualAlloc(
        NULL,                 // system selects address
        4096,     // size of allocation
        MEM_COMMIT,   // allocate reserved pages
        PAGE_READWRITE);       // protection = no access
   if (lpvBase == NULL )
   return;

 //向该内存里面写些东西
 unsigned char *ustr=(unsigned char *)lpvBase;
 ustr[0]=0x89;

 //修改为“只读”属性，验证是否能写入
 DWORD dw;
 VirtualProtect(lpvBase,4096,PAGE_READONLY,&dw);
// ustr[0]=0x44; //失败

 //修改为“不可访问”，验证是否能读出
 VirtualProtect(lpvBase,4096,PAGE_NOACCESS,&dw);
// dw = ustr[0]; //失败
bool flag = VirtualFree(lpvBase,4096, MEM_DECOMMIT);
if (flag == TRUE)
{
    printf("释放成功！\n");
}
else
{
    printf("释放失败！\n");
}
// ustr[0]=0x44; //失败
 return;
} 
```

* 修改为只读属性，不能成功写入。修改为不可访问，不能成功读出 。释放后也不能成功读写。

## 参考文献

* [VirtualAlloc](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)
* [VirtualFree](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualfree)
* [VirtualProtect](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect)
* [使用VirtualAlloc创建虚拟内存，修改可读、可写属性](https://blog.csdn.net/dijkstar/article/details/1686965)
* [malloc内存后的释放](https://blog.csdn.net/wangqingchuan92/article/details/78852460)